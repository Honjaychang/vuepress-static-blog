(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{392:function(_,v,e){"use strict";e.r(v);var t=e(42),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"计网"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计网"}},[_._v("#")]),_._v(" 计网")]),_._v(" "),e("h2",{attrs:{id:"tcp和udp的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[_._v("#")]),_._v(" TCP和UDP的区别")]),_._v(" "),e("h5",{attrs:{id:"连接方面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#连接方面"}},[_._v("#")]),_._v(" 连接方面")]),_._v(" "),e("ul",[e("li",[_._v("TCP面向连接，UDP不需要连接")]),_._v(" "),e("li",[_._v("TCP需要三次握手四次挥手请求连接  "),e("a",{attrs:{href:"https://segmentfault.com/a/1190000018592072",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP是如何实现可靠连接的？"),e("OutboundLink")],1),_._v(" "),e("ul",[e("li",[_._v("超时重传")])])])]),_._v(" "),e("h5",{attrs:{id:"可靠性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可靠性"}},[_._v("#")]),_._v(" 可靠性")]),_._v(" "),e("ul",[e("li",[_._v("TCP是可靠传输；一旦传输过程中丢包的话会进行重传")]),_._v(" "),e("li",[_._v("UDP是不可靠传输，但会最大努力交付")])]),_._v(" "),e("h5",{attrs:{id:"工作效率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工作效率"}},[_._v("#")]),_._v(" 工作效率")]),_._v(" "),e("ul",[e("li",[_._v("UDP实时性高，比TCP工作效率高")]),_._v(" "),e("li",[_._v("因为不需要建立连接，更不需要复杂的握手挥手以及复杂的算法，也没有4重传机制")])]),_._v(" "),e("h5",{attrs:{id:"是否支持多对多"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#是否支持多对多"}},[_._v("#")]),_._v(" 是否支持多对多")]),_._v(" "),e("ul",[e("li",[_._v("TCP是点对点的")]),_._v(" "),e("li",[_._v("UDP支持一对一，一对多，多对多")])]),_._v(" "),e("h5",{attrs:{id:"首部大小"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首部大小"}},[_._v("#")]),_._v(" 首部大小")]),_._v(" "),e("ul",[e("li",[_._v("TCP首部占20字节")]),_._v(" "),e("li",[_._v("UDP首部占8字节，首部开销小。同样的报文内容，UDP会比TCP更高效。")])]),_._v(" "),e("h2",{attrs:{id:"三次握手四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手四次挥手"}},[_._v("#")]),_._v(" 三次握手四次挥手")]),_._v(" "),e("ul",[e("li",[_._v("图源：博客 "),e("a",{attrs:{href:"https://blog.csdn.net/qzcsu/article/details/72861891",target:"_blank",rel:"noopener noreferrer"}},[_._v("两张动图-彻底明白TCP的三次握手与四次挥手"),e("OutboundLink")],1)]),_._v(" "),e("li",[e("code",[_._v("SYN(Synchronize) 同步")]),_._v(" "),e("code",[_._v("ACK 确认")])])]),_._v(" "),e("h5",{attrs:{id:"三次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://cdn.jsdelivr.net/gh/honjaychang/icopicture/blog/image-20210312214207519.png",alt:"image-20210312214207519"}}),_._v(" "),e("p",[e("strong",[_._v("实质")]),_._v("：客户端连接服务器指定端口 建立TCP连接，并同步双方的序列号和确认号，交换"),e("code",[_._v("TCP窗口大小")]),_._v("信息")]),_._v(" "),e("ul",[e("li",[_._v("服务端调用"),e("code",[_._v("listen")]),_._v("系统命令，进入监听状态，等待客户端的连接。")]),_._v(" "),e("li",[_._v("客户端向服务端发送"),e("code",[_._v("连接请求报文")]),_._v("，其中TCP标志位里"),e("code",[_._v("SYN=1，ACK=0")]),_._v("，选择一个初始的序号"),e("code",[_._v("x")]),_._v("。")]),_._v(" "),e("li",[_._v("服务端收到请求报文，向 客户端 发送 "),e("code",[_._v("连接确认报文")]),_._v(" ，"),e("code",[_._v("SYN=1，ACK=1")]),_._v("，确认号为 "),e("code",[_._v("x+1")]),_._v("，同时也选择一个初始的序号"),e("code",[_._v("y")]),_._v("。")]),_._v(" "),e("li",[_._v("客户端 收到 服务端的连接确认报文后，还要向 服务端 "),e("code",[_._v("发出确认")]),_._v("，确认号为 "),e("code",[_._v("y+1")]),_._v("，序号为 "),e("code",[_._v("x+1")]),_._v("。")]),_._v(" "),e("li",[_._v("服务端 收到 客户端 的确认后，"),e("code",[_._v("连接建立")]),_._v("。")])]),_._v(" "),e("h5",{attrs:{id:"四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://cdn.jsdelivr.net/gh/honjaychang/icopicture/blog/image-20210312214227886.png",alt:"image-20210312214227886"}}),_._v(" "),e("ul",[e("li",[_._v("当主动方关闭连接时，会发送 "),e("code",[_._v("FIN")]),_._v(" 报文，此时主动方的连接状态由 "),e("code",[_._v("ESTABLISHED")]),_._v(" 变为 "),e("code",[_._v("FIN_WAIT1")]),_._v("。当被动方收到 "),e("code",[_._v("FIN")]),_._v(" 报文后，内核自动回复 "),e("code",[_._v("ACK")]),_._v(" 报文，连接状态由 "),e("code",[_._v("ESTABLISHED")]),_._v(" 变为 "),e("code",[_._v("CLOSE_WAIT")]),_._v("，顾名思义，它在等待进程调用 "),e("code",[_._v("close")]),_._v(" 函数关闭连接。当主动方接收到这个 "),e("code",[_._v("ACK")]),_._v(" 报文后，连接状态由 "),e("code",[_._v("FIN_WAIT1")]),_._v(" 变为 "),e("code",[_._v("FIN_WAIT2")]),_._v("，主动方的发送通道就关闭了。")]),_._v(" "),e("li",[_._v("再来看被动方的发送通道是如何关闭的。当被动方进入 "),e("code",[_._v("CLOSE_WAIT")]),_._v(" 状态时，进程的 "),e("code",[_._v("read")]),_._v(" 函数会返回 0，这样开发人员就会有针对性地调用 "),e("code",[_._v("close 函数")]),_._v("，进而触发内核发送 "),e("code",[_._v("FIN")]),_._v(" 报文，此时被动方连接的状态变为 "),e("code",[_._v("LAST_ACK")]),_._v("。当主动方收到这个 "),e("code",[_._v("FIN")]),_._v(" 报文时，内核会自动回复 "),e("code",[_._v("ACK")]),_._v("，同时连接的状态由 "),e("code",[_._v("FIN_WAIT2")]),_._v(" 变为 "),e("code",[_._v("TIME_WAIT")]),_._v("，"),e("code",[_._v("Linux")]),_._v(" 系统下大约 "),e("code",[_._v("1 分钟")]),_._v("后 TIME_WAIT 状态的连接才会彻底关闭。而被动方收到 "),e("code",[_._v("ACK")]),_._v(" 报文后，连接就会关闭。")])]),_._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[_._v("那为什么需要三次握手，四次挥手呢？\n"),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("3")]),_._v("次握手的作用就是双方都能明确自己和对方的收、发能力是正常的，三次连接是保证可靠性的最小握手次数。\n"),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("4")]),_._v("次挥手呐，"),e("span",{pre:!0,attrs:{class:"token constant"}},[_._v("TCP")]),_._v("的全双工通信断开连接，需要双方的都确认断开。\n\t当客户端确认自己没有数据要传给服务器时，并不能保证服务器也没有数据要发送了\n  前两次挥手是客户端和服务器对连接断开的确认\n  第三次服务器会将剩下的数据发给客户端\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br"),e("span",{staticClass:"line-number"},[_._v("3")]),e("br"),e("span",{staticClass:"line-number"},[_._v("4")]),e("br"),e("span",{staticClass:"line-number"},[_._v("5")]),e("br"),e("span",{staticClass:"line-number"},[_._v("6")]),e("br")])]),e("p",[e("code",[_._v("Ref")])]),_._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://yuanrengu.com/2020/77eef79f.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("面试官，不要再问我三次握手和四次挥手"),e("OutboundLink")],1)]),_._v(" "),e("li",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw",target:"_blank",rel:"noopener noreferrer"}},[_._v("硬不硬你说了算！近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题"),e("OutboundLink")],1)]),_._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/108822858",target:"_blank",rel:"noopener noreferrer"}},[_._v("一文搞定 UDP 和 TCP 高频面试题！"),e("OutboundLink")],1)])]),_._v(" "),e("h2",{attrs:{id:"osi七层模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#osi七层模型"}},[_._v("#")]),_._v(" OSI七层模型")]),_._v(" "),e("ul",[e("li",[_._v("TCP 属于传输层")]),_._v(" "),e("li",[_._v("发送数据是封装过程 接收则是解封装")])]),_._v(" "),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"HTTPs://cdn.jsdelivr.net/gh/honjaychang/icopicture/blog/image-20210312132823375.png",alt:"image-20210312132823375"}}),_._v(" "),e("ul",[e("li",[_._v("物理层：利用物理传输介质为数据链路层提供物理连接，实现比特流的透明传输")]),_._v(" "),e("li",[_._v("数据链路层：\n"),e("ul",[e("li",[_._v("交换机 帧（帧是放置数据的、逻辑的、结构化的包")]),_._v(" "),e("li",[_._v("将来自物理层的原始数据进行MAC地址的封装与解封装")]),_._v(" "),e("li",[_._v("点到点传输")])])]),_._v(" "),e("li",[_._v("网络层：\n"),e("ul",[e("li",[_._v("ARP：地址解析协议")]),_._v(" "),e("li",[_._v("路由器 数据包分组")]),_._v(" "),e("li",[_._v("将数据链路层的数据进行IP地址的封装与解封装")]),_._v(" "),e("li",[_._v("IP地址寻址问题  路由算法：确定从源结点沿着网络到目的结点的路由选择")]),_._v(" "),e("li",[_._v("数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信")])])]),_._v(" "),e("li",[_._v("传输层：\n"),e("ul",[e("li",[_._v("定义传输数据的协议和端口 TCP UDP")]),_._v(" "),e("li",[_._v("将从下层接收的数据进行分段和传输，到达目的地址后再进行重组")]),_._v(" "),e("li",[_._v("向用户提供可靠的、透明的、端到端的数据传输，以及差错控制和流量控制机制")]),_._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/weixin_43914604/article/details/105531547?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP流量控制"),e("OutboundLink")],1)])])]),_._v(" "),e("li",[_._v("会话层：\n"),e("ul",[e("li",[_._v("会话层建立、管理和终止应用程序进程之间的会话和数据交换")])])]),_._v(" "),e("li",[_._v("表示层\n"),e("ul",[e("li",[_._v("主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等")])])]),_._v(" "),e("li",[_._v("应用层\n"),e("ul",[e("li",[_._v("终端应用")])])])]),_._v(" "),e("h2",{attrs:{id:"https-http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https-http"}},[_._v("#")]),_._v(" HTTPS & HTTP")]),_._v(" "),e("p",[_._v("HTTP：无状态"),e("code",[_._v("(stateless)")]),_._v("协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。即协议对于发送过的请求或响应都不做持久化处理")]),_._v(" "),e("h4",{attrs:{id:"区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[_._v("#")]),_._v(" 区别")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("HTTP")]),_._v("：无状态无连接，而且是明文传输，不安全 80")]),_._v(" "),e("li",[e("code",[_._v("HTTPS")]),_._v("：传输内容加密，身份验证，保证数据完整性  "),e("code",[_._v("HTTP + SSL/TLS")]),_._v(" 443")])]),_._v(" "),e("h5",{attrs:{id:"http-的不足"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-的不足"}},[_._v("#")]),_._v(" HTTP 的不足")]),_._v(" "),e("ul",[e("li",[_._v("通信使用明文，内容可能会被窃听  ->  通信加密  "),e("s",[_._v("数据加密")])]),_._v(" "),e("li",[_._v("不验证通信方的身份，因此有可能遭遇伪装  -> "),e("code",[_._v("SSL HTTPS")]),_._v(" 数字证书")]),_._v(" "),e("li",[_._v("无法证明报文的完整性，所以有可能已遭篡改 -> 中间人攻击 MD5 数字签名")])]),_._v(" "),e("h5",{attrs:{id:"完整性检测-数字签名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#完整性检测-数字签名"}},[_._v("#")]),_._v(" 完整性检测 - 数字签名")]),_._v(" "),e("ul",[e("li",[_._v("将一段文本通过"),e("code",[_._v("hash")]),_._v("函数生成消息摘要，再通过客户端的私钥进行加密生成数字签名")]),_._v(" "),e("li",[_._v("服务器收到数字签名后先用公钥进行解密 得到消息摘要\n"),e("ul",[e("li",[_._v("然后对收到的原文也进行"),e("code",[_._v("hash")]),_._v("生成消息摘要")]),_._v(" "),e("li",[_._v("比较前后两次消息摘要  如果相同  则证明完整没有被篡改")])])])]),_._v(" "),e("h5",{attrs:{id:"数字证书"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数字证书"}},[_._v("#")]),_._v(" 数字证书")]),_._v(" "),e("ul",[e("li",[_._v("解决通信身份可能被伪装问题")]),_._v(" "),e("li",[_._v("服务器运营人员向第三方证书机构提交CA公钥、组织信息、域名等信息进行申请认证")]),_._v(" "),e("li",[_._v("数字证书机构通过线上线下等手段去验证所提供的信息是否合法。合法的话会向申请者颁发证书（包含CA公钥、证书机构和所有者组织信息、证书有效时间、序列号等信息，还包含一个签名（使用散列函数计算公开明文的消息摘要并通过CA的私钥进行加密 => 签名")]),_._v(" "),e("li",[_._v("客户端向目标服务器发起请求时会返回相应的证书文件")]),_._v(" "),e("li",[_._v("客户端读取证书中信息，进行相同的散列函数计算得到消息摘要。通过CA中的公钥解密签名数据，对比证书的消息摘要是否一致来判断是否合法")])]),_._v(" "),e("h4",{attrs:{id:"https实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https实现原理"}},[_._v("#")]),_._v(" HTTPS实现原理")]),_._v(" "),e("p",[e("strong",[_._v("HTTP +")]),_._v(" 加密 "),e("strong",[_._v("+")]),_._v(" 认证 "),e("strong",[_._v("+")]),_._v(" 完整性保护  = "),e("strong",[_._v("HTTPS")])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("过程")]),_._v(" "),e("ul",[e("li",[_._v("客户端发送消息给服务器（包含可用的加密算法和压缩算法")]),_._v(" "),e("li",[_._v("服务器返回消息给客户端（包含选用的加密和压缩算法以及数字证书认证机构CA签发的证书（包含公钥 + 证书所应用的域名范围")]),_._v(" "),e("li",[_._v("客户端去验证公钥证书 是否合法")]),_._v(" "),e("li",[_._v("客户端使用伪随机数生成传输信息所用的对称密钥，然后通过证书的公钥去传输对称密钥")]),_._v(" "),e("li",[_._v("服务端接收到信息后，用自己的私钥去解密来获得对称密钥")]),_._v(" "),e("li",[_._v("服务端使用对称密钥与客户端进行通信（此时双方都已经拥有了对称密钥")])])]),_._v(" "),e("li",[e("p",[_._v("SSL 公钥加密的算法")]),_._v(" "),e("ul",[e("li",[_._v("对称加密的问题：密钥分发的问题 安全性问题")])])]),_._v(" "),e("li",[e("p",[_._v("HTTPS采用 共享密钥(对称加密) 和 公开密钥(非对称加密)两者混用的加密机制")]),_._v(" "),e("ul",[e("li",[_._v("非对称：交换对称密钥")]),_._v(" "),e("li",[_._v("对称：信息交换")])])])]),_._v(" "),e("p",[e("code",[_._v("Ref")])]),_._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6844903830916694030",target:"_blank",rel:"noopener noreferrer"}},[_._v("深入理解HTTPS工作原理"),e("OutboundLink")],1)])]),_._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1005197",target:"_blank",rel:"noopener noreferrer"}},[_._v("深入浅出 HTTPS 工作原理"),e("OutboundLink")],1)])])]),_._v(" "),e("h4",{attrs:{id:"http版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http版本"}},[_._v("#")]),_._v(" HTTP版本")]),_._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[_._v("使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分："),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("1.")]),_._v(" 判断传输数据是否达到了Content"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("-")]),_._v("Length 指示的大小；"),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("2.")]),_._v(" 动态生成的文件没有 Content"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("-")]),_._v("Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束，\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br")])]),e("ul",[e("li",[_._v("HTTP/0.9：只能进行"),e("code",[_._v("get")]),_._v("请求，发送纯文本")]),_._v(" "),e("li",[_._v("HTTP/1.0：添加了"),e("code",[_._v("POST、HEAD、OPTION、PUT、DELETE")]),_._v("等")]),_._v(" "),e("li",[_._v("HTTP/1.1：\n"),e("ul",[e("li",[_._v("默认支持了长连接"),e("code",[_._v("keep-alive")]),_._v("：旨在建立 "),e("strong",[_._v("1")]),_._v(" 次 "),e("strong",[_._v("TCP")]),_._v(" 连接后进行多次请求和响应的交互  "),e("code",[_._v("Keep-Alive: timeout=5, max=100")])]),_._v(" "),e("li",[_._v("管线化：不用等待响应亦可直接发送下一个请求，就能够做到同时并行发送多个请求")]),_._v(" "),e("li",[_._v("虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 "),e("code",[_._v("Cookie")]),_._v(" 技术（通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态")]),_._v(" "),e("li",[_._v("增加了"),e("code",[_._v("host")]),_._v(" 域，而且节约带宽?")])])]),_._v(" "),e("li",[_._v("HTTP/2：\n"),e("ul",[e("li",[_._v("多路复用：让所有的通信都在一个TCP连接上完成，实现了请求的并发")]),_._v(" "),e("li",[_._v("头部压缩：利用HPACK算法压缩头部的"),e("code",[_._v("User-Agent Cookie Accept Server Rabge")]),_._v("等字段")]),_._v(" "),e("li",[_._v("服务器推送：使得服务器可以预测客户端需要的资源，主动推送到客户端")])])])]),_._v(" "),e("p",[e("code",[_._v("Ref:")])]),_._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"https://g.yuque.com/kougazhang/network/ccyd8g",target:"_blank",rel:"noopener noreferrer"}},[_._v("简介: http/https/http2"),e("OutboundLink")],1)])]),_._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://blog.51cto.com/12118369/1962662",target:"_blank",rel:"noopener noreferrer"}},[_._v("http1.0，http1.1和http2.0的区别"),e("OutboundLink")],1)])])]),_._v(" "),e("p",[e("code",[_._v("cookie")]),_._v(" 是存储在浏览器的小段文本，会在浏览器每次向同一服务器再发起请求时被携带并发送到服务 器上。我们可以把状态信息放在"),e("code",[_._v("cookie")]),_._v("里，带给服务器。")]),_._v(" "),e("p",[e("code",[_._v("session")]),_._v(" 是存储在服务器的用户数据。浏览器第一次向服务器发起请求时，服务器会为当前会话创建一个 "),e("code",[_._v("session")]),_._v("，并且把对应的 "),e("code",[_._v("session-id")]),_._v(" 写入 "),e("code",[_._v("cookie")]),_._v(" 中，用来标识 "),e("code",[_._v("session")]),_._v("。此后，每次用户的请求都会携带 一个包含了 "),e("code",[_._v("session-id")]),_._v(" 的 "),e("code",[_._v("cookie")]),_._v("，服务器解析出了 "),e("code",[_._v("session-id")]),_._v("，便能定位到用户的用户信息。")]),_._v(" "),e("h2",{attrs:{id:"浏览器输入网址到页面渲染全过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器输入网址到页面渲染全过程"}},[_._v("#")]),_._v(" 浏览器输入网址到页面渲染全过程")]),_._v(" "),e("ul",[e("li",[_._v("DNS解析：域名解析为IP地址\n"),e("ul",[e("li",[_._v("缓存命中")])])]),_._v(" "),e("li",[_._v("浏览器缓存 => 系统缓存 => 路由器缓存 => "),e("code",[_._v("ISP")]),_._v("服务器缓存 => 根域名服务器缓存 => 顶级域名服务器缓存 => 主域名服务器缓存")]),_._v(" "),e("li",[_._v("TCP连接：三次握手")]),_._v(" "),e("li",[_._v("发送HTTP请求")]),_._v(" "),e("li",[_._v("服务器处理请求  并  返回HTTP响应报文")]),_._v(" "),e("li",[_._v("浏览器解析渲染页面："),e("code",[_._v("HTML、CSS、JS")]),_._v("文件")]),_._v(" "),e("li",[e("code",[_._v("DOM Tree + CSSOM => Render Tree => JS => Render Tree")])]),_._v(" "),e("li",[_._v("连接结束")])]),_._v(" "),e("p",[e("code",[_._v("Ref:")])]),_._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000006879700",target:"_blank",rel:"noopener noreferrer"}},[_._v("前端经典面试题: 从输入URL到页面加载发生了什么？"),e("OutboundLink")],1)]),_._v(" "),e("li",[e("a",{attrs:{href:"https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/",target:"_blank",rel:"noopener noreferrer"}},[_._v("经典面试题：从 URL 输入到页面展现到底发生什么？"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=r.exports}}]);